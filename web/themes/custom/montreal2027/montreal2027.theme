<?php

use Drupal\Core\Form\FormStateInterface;
use Drupal\Component\Utility\Html;

/**
 * Implements hook_form_alter().
 */
function montreal2027_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if ($form_id === 'search_block_form') {
    $form['keys']['#attributes']['placeholder'] = t('I am looking for'); // Add placeholder
  }
}

function montreal2027_preprocess_block__system_branding_block(&$variables) {
  // Wrap each word in the site slogan with a <span> so it can be styled separately.
  if (!empty($variables['site_slogan'])) {
    // This is user provided input, remove any existing markup and work with the plain text.
    $slogan_text = strip_tags($variables['site_slogan']['#markup']);

    // Explode by whitespace.
    $parts = explode(' ', $slogan_text);

    $wrapped = '';
    foreach ($parts as $part) {
      if (strlen($wrapped) > 0) {
        // Add a space before all but the first word.
        $wrapped .= ' ';
      }

      // Escape the word and wrap it because it's user provided input.
      $wrapped .= '<span class="slogan-word">' . Html::escape($part) . '</span>';
    }

    // Set as render array to ensure it's output as safe markup.
    $variables['site_slogan'] = ['#markup' => $wrapped];
  }
}

/**
 * Get the image alt text and a usable URL from a variety of field item entities.
 *
 * @param mixed $item A field item, media field item, or render array fragment.
 * @param string $image_style The machine name of the image style to use for the URL.
 * @returns array An associative array with keys 'alt' and 'url'.
 */
function get_image_info(mixed $item, string $image_style='convert_only') {
  $result = [
    'alt' => '',
    'url' => '',
  ];

  // Handle render-array wrapping where the raw field item is stored under '#item'.
  if (is_array($item) && isset($item['#item'])) {
    $item = $item['#item'];
  }

  // If item is a render array that is itself a file render element, try '#file'.
  if (is_array($item) && isset($item['#file']) && is_object($item['#file'])) {
    $file = $item['#file'];
    // Try to get alt from '#options' if provided.
    $alt = '';
    if (isset($item['#options']['alt'])) {
      $alt = (string) $item['#options']['alt'];
    }
    $result['alt'] = $alt;

    // Build URL from file entity if possible.
    if (method_exists($file, 'getFileUri')) {
      $uri = $file->getFileUri();
      if ($uri) {
        $style = \Drupal\image\Entity\ImageStyle::load($image_style);
        if ($style) {
          $result['url'] = $style->buildUrl($uri);
        } else {
          $result['url'] = \Drupal::service('file_url_generator')->generateAbsoluteString($uri);
        }
      }
    }

    return $result;
  }

  // If $item is an object (FieldItem, File, Media, etc.) inspect it.
  if (is_object($item)) {
    $alt = '';
    $file = null;

    // If the item directly has an alt property (common for image field items).
    if (isset($item->alt)) {
      $alt = (string) $item->alt;
    } else {
      // Try method-based access; some FieldItem implementations expose get('alt').
      if (method_exists($item, 'get')) {
        try {
          $altVal = $item->get('alt')->getValue();
          if (is_array($altVal)) {
            $alt = reset($altVal) ?: '';
          } elseif (is_string($altVal)) {
            $alt = $altVal;
          }
        } catch (\Throwable $e) {
          // ignore
        }
      }
    }

    // If the item references an entity (could be a file or a media entity).
    if (isset($item->entity) && is_object($item->entity)) {
      $entity = $item->entity;
      try {
        $etype = method_exists($entity, 'getEntityTypeId') ? $entity->getEntityTypeId() : '';
      } catch (\Throwable $e) {
        $etype = '';
      }

      // If it's a media entity, find the media's image field item and extract file/alt.
      if ($etype === 'media') {
        $media = $entity;
        $possible_image_fields = [
          'field_media_image',
          'field_media_photo',
          'field_image',
          'image',
          'field_media_picture',
        ];
        $image_item = null;
        foreach ($possible_image_fields as $field_name) {
          if ($media->hasField($field_name) && !$media->get($field_name)->isEmpty()) {
            $image_item = $media->get($field_name)->first();
            break;
          }
        }
        if ($image_item) {
          // Extract alt from the media's image field item if available.
          if (isset($image_item->alt)) {
            $alt = (string) $image_item->alt;
          } else {
            try {
              $altVal = $image_item->get('alt')->getValue();
              if (is_array($altVal)) {
                $alt = reset($altVal) ?: '';
              } elseif (is_string($altVal)) {
                $alt = $altVal;
              }
            } catch (\Throwable $e) {
              // ignore
            }
          }

          // File entity referenced by the media image field.
          if (isset($image_item->entity) && is_object($image_item->entity)) {
            $file = $image_item->entity;
          }
        }

        // Fallback: if no image_item resolved, try the media's field_media_image directly.
        if (!$file && $media->hasField('field_media_image') && !$media->get('field_media_image')->isEmpty()) {
          $maybe = $media->get('field_media_image')->first();
          if ($maybe && isset($maybe->entity) && is_object($maybe->entity)) {
            $file = $maybe->entity;
          }
        }
      }
      else {
        // If the referenced entity is a file entity, use it directly.
        if ($etype === 'file' || is_subclass_of(get_class($entity), 'Drupal\\file\\Entity\\File') || method_exists($entity, 'getFileUri')) {
          $file = $entity;
        }
      }
    }

    // Build the image URL from the resolved file entity when possible.
    if ($file) {
      try {
        $uri = method_exists($file, 'getFileUri') ? $file->getFileUri() : '';
        if ($uri) {
          $style = \Drupal\image\Entity\ImageStyle::load($image_style);
          if ($style) {
            $result['url'] = $style->buildUrl($uri);
          } else {
            $result['url'] = \Drupal::service('file_url_generator')->generateAbsoluteString($uri);
          }
        }
      } catch (\Throwable $e) {
        // ignore
      }
    }

    $result['alt'] = $alt;
    return $result;
  }

  // Nothing resolved.
  return $result;
}

/**
 * Preprocess for the node guest teaser template.
 *
 * This uses the generic resolver above to expose guest_image_alt and
 * guest_image_url to the twig template.
 */
function montreal2027_preprocess_node__guest__teaser(array &$variables) {
  // Default values.
  $variables['guest_image_alt'] = '';
  $variables['guest_image_url'] = '';

  if (isset($variables['node']) && $variables['node']->hasField('field_guest_photo') && !$variables['node']->get('field_guest_photo')->isEmpty()) {
    $item = $variables['node']->get('field_guest_photo')->first();
    $info = get_image_info($item, 'guest_photos');

    // Fallback alt to node label if empty.
    $variables['guest_image_alt'] = $info['alt'] !== '' ? $info['alt'] : $variables['node']->label();
    $variables['guest_image_url'] = $info['url'] ?: '';

    $language = \Drupal::languageManager()->getCurrentLanguage();
    $variables['current_langcode'] = $language->getId();
  }
}

function montreal2027_preprocess_block__montreal2027_content(&$variables) {
  // Get the current node object if available.
  $node = \Drupal::routeMatch()->getParameter('node');

  // Check if a node was found and pass it to the template.
  if ($node instanceof \Drupal\node\NodeInterface) {
    $variables['current_node'] = $node;
  }
}

/**
 * Preprocess for paragraph--guest-block.twig and paragraph--guests.twig templates.
 *
 * Resolve the referenced taxonomy term entity from either paragraph.field_block
 * (guest_block) or paragraph.field_guest_type (guests) and pick the appropriate
 * translation using a robust server-side language detection strategy.
 * Expose 'guest_block_entity_translated' and simple conveniences to Twig so
 * templates don't need to reimplement language detection logic.
 */
function montreal2027_preprocess_paragraph__guest_block(array &$variables)
{
  montreal2027_preprocess_guest_taxonomy_paragraph($variables);
}

/**
 * Preprocess for paragraph--guests.twig template.
 *
 * Uses the same logic as guest_block to resolve taxonomy term translations.
 */
function montreal2027_preprocess_paragraph__guests(array &$variables)
{
  montreal2027_preprocess_guest_taxonomy_paragraph($variables);
}

/**
 * Shared preprocessing logic for guest taxonomy paragraphs.
 *
 * Handles both field_block (guest_block) and field_guest_type (guests).
 */
function montreal2027_preprocess_guest_taxonomy_paragraph(array &$variables)
{
  if (empty($variables['paragraph'])) {
    return;
  }
  $paragraph = $variables['paragraph'];

  // Default exposures for Twig.
  $variables['guest_block_entity_translated'] = NULL;
  $variables['guest_block_langcode'] = NULL;
  $variables['guest_block_title'] = '';
  $variables['guest_block_title_plural'] = '';
  $variables['guest_block_description'] = '';

  // Determine which field to use based on paragraph type
  $referenced = NULL;
  if ($paragraph->hasField('field_block') && !$paragraph->get('field_block')->isEmpty()) {
    $referenced = $paragraph->get('field_block')->entity;
  } elseif ($paragraph->hasField('field_guest_type') && !$paragraph->get('field_guest_type')->isEmpty()) {
    $referenced = $paragraph->get('field_guest_type')->entity;
  }

  if (!$referenced) {
    return;
  }

  // Robust language detection (server-side): prefer entity langcode, then
  // current language from language manager, then request attributes.
  $langcode = NULL;

  // 1) Prefer the entity's own langcode (this is safe and explicit).
  try {
    $entity_lang = method_exists($referenced, 'getLangcode') ? $referenced->getLangcode() : NULL;
    if ($entity_lang) {
      $langcode = $entity_lang;
    }
  } catch (\Throwable $e) {
    // ignore
  }

  // 2) Language manager current language
  if (empty($langcode)) {
    try {
      $langcode = \Drupal::languageManager()->getCurrentLanguage()->getId();
    } catch (\Throwable $e) {
      // ignore
    }
  }

  // 3) Request attributes (Negotiation may set these)
  if (empty($langcode)) {
    $request = \Drupal::request();
    if ($request) {
      $req_lang = $request->attributes->get('_language');
      if ($req_lang && method_exists($req_lang, 'getId')) {
        $langcode = $req_lang->getId();
      }
    }
  }

  // 4) Locale fallback
  if (empty($langcode)) {
    $request = \Drupal::request();
    if ($request) {
      $locale_attr = $request->attributes->get('_locale');
      if ($locale_attr) {
        $langcode = preg_split('/[_-]/', (string)$locale_attr)[0];
      } else {
        $locale = $request->getLocale();
        if ($locale) {
          $langcode = preg_split('/[_-]/', (string)$locale)[0];
        }
      }
    }
  }

  // 5) Fallback: derive language from the first URL path segment (path prefix)
  // This handles cases where language negotiation uses path prefixes (e.g. /fr/...).
  if (empty($langcode)) {
    $request = \Drupal::request();
    if ($request) {
      $path = trim($request->getPathInfo(), '/');

      // If getPathInfo() has had the language prefix removed (some middlewares
      // or language negotiation can do this), try the original request URI
      // and strip base path.
      if ($path === '') {
        $raw = $request->getRequestUri();
        // Remove query string
        $raw = preg_replace('/\?.*/', '', $raw);
        $base = $request->getBasePath() ?: '';
        if ($base && strpos($raw, $base) === 0) {
          $raw = substr($raw, strlen($base));
        }
        $raw = trim($raw, '/');
        $path = $raw;
      }

      if ($path !== '') {
        $first_segment = preg_split('#/+#', $path)[0];
        // Check against configured languages. Accept exact matches or primary-subtag matches
        try {
          $languages = \Drupal::languageManager()->getLanguages();
          foreach ($languages as $lid => $lang) {
            // Exact key match first.
            if ($first_segment === $lid) {
              $langcode = $lid;
              break;
            }
            // Accept matching the primary subtag (e.g. 'fr' for 'fr-FR' or 'fr_CA').
            $primary = preg_split('/[_-]/', $lid)[0];
            if ($first_segment === $primary) {
              $langcode = $lid;
              break;
            }
          }
        } catch (\Throwable $e) {
          // ignore
        }
      }
    }
  }

  // Determine translated entity (if available)
  $translated = $referenced;
  if ($langcode && $referenced->hasTranslation($langcode)) {
    try {
      $translated = $referenced->getTranslation($langcode);
    } catch (\Throwable $e) {
      // ignore and fall back to original
    }
  }

  $variables['guest_block_entity_translated'] = $translated;
  $variables['guest_block_langcode'] = $langcode;

  // Convenience values for the template
  try {
    $variables['guest_block_title'] = $translated->label();
  } catch (\Throwable $e) {
    $variables['guest_block_title'] = '';
  }

  // Title plural (field_plural)
  if ($translated && $translated->hasField('field_plural') && !$translated->get('field_plural')->isEmpty()) {
    try {
      $variables['guest_block_title_plural'] = (string)$translated->get('field_plural')->first()->value;
    } catch (\Throwable $e) {
      $variables['guest_block_title_plural'] = '';
    }
  }

  // Description - guard for the field existence
  if ($translated && $translated->hasField('description') && !$translated->get('description')->isEmpty()) {
    try {
      $variables['guest_block_description'] = (string) $translated->get('description')->first()->value;
    } catch (\Throwable $e) {
      $variables['guest_block_description'] = '';
    }
  }
}
